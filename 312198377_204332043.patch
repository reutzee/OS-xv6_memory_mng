diff --git a/.proc.c.swp b/.proc.c.swp
new file mode 100644
index 0000000..fce3bf7
Binary files /dev/null and b/.proc.c.swp differ
diff --git a/BUGS b/BUGS
old mode 100644
new mode 100755
diff --git a/LICENSE b/LICENSE
old mode 100644
new mode 100755
diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index 06eea5d..fd2e93d
--- a/Makefile
+++ b/Makefile
@@ -71,6 +71,17 @@ QEMU = $(shell if which qemu > /dev/null; \
 	echo "***" 1>&2; exit 1)
 endif
 
+ifndef SELECTION
+SELECTION := SCFIFO
+endif
+
+ifndef VERBOSE_PRINT
+VERBOSE_PRINT := FALSE
+endif
+
+CFLAGS += -D$(SELECTION) -D$(VERBOSE_PRINT)
+
+
 CC = $(TOOLPREFIX)gcc
 AS = $(TOOLPREFIX)gas
 LD = $(TOOLPREFIX)ld
@@ -79,6 +90,7 @@ OBJDUMP = $(TOOLPREFIX)objdump
 CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
 #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+CFLAGS += -D$(SELECTION) -D$(VERBOSE_PRINT)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
@@ -173,6 +185,10 @@ UPROGS=\
 	_stressfs\
 	_usertests\
 	_wc\
+	_myMemTest\
+	_fork_test\
+	_fork_test2\
+	_linear_test\
 	_zombie\
 
 fs.img: mkfs README $(UPROGS)
diff --git a/Notes b/Notes
old mode 100644
new mode 100755
diff --git a/README b/README
old mode 100644
new mode 100755
diff --git a/TRICKS b/TRICKS
old mode 100644
new mode 100755
diff --git a/asm.h b/asm.h
old mode 100644
new mode 100755
diff --git a/bio.c b/bio.c
old mode 100644
new mode 100755
diff --git a/bootasm.S b/bootasm.S
old mode 100644
new mode 100755
diff --git a/bootmain.c b/bootmain.c
old mode 100644
new mode 100755
diff --git a/buf.h b/buf.h
old mode 100644
new mode 100755
diff --git a/cat.c b/cat.c
old mode 100644
new mode 100755
diff --git a/console.c b/console.c
old mode 100644
new mode 100755
diff --git a/date.h b/date.h
old mode 100644
new mode 100755
diff --git a/defs.h b/defs.h
old mode 100644
new mode 100755
index 7ad2380..2465c99
--- a/defs.h
+++ b/defs.h
@@ -56,6 +56,7 @@ int		createSwapFile(struct proc* p);
 int		readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
 int		writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
 int		removeSwapFile(struct proc* p);
+void copySwapFile(struct proc* from, struct proc* to);
 
 // ide.c
 void            ideinit(void);
@@ -72,7 +73,9 @@ char*           kalloc(void);
 void            kfree(char*);
 void            kinit1(void*, void*);
 void            kinit2(void*, void*);
-
+int 			getTotalPageskernel(void);
+int 			getTotalfreePages();
+int 			getfreepages(void);
 // kbd.c
 void            kbdintr(void);
 
@@ -124,6 +127,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void			procdump_proc(struct proc* p);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -164,6 +168,7 @@ int             fetchint(uint, int*);
 int             fetchstr(uint, char**);
 void            syscall(void);
 
+
 // timer.c
 void            timerinit(void);
 
@@ -184,6 +189,7 @@ void            kvmalloc(void);
 pde_t*          setupkvm(void);
 char*           uva2ka(pde_t*, char*);
 int             allocuvm(pde_t*, uint, uint);
+int             allocuvm_exec(pde_t*, uint, uint,int);
 int             deallocuvm(pde_t*, uint, uint);
 void            freevm(pde_t*);
 void            inituvm(pde_t*, char*, uint);
@@ -193,6 +199,19 @@ void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
-
+void            fixPagedInPTE(int userPageVAddr, int pagePAddr, pde_t * pgdir);
+int 			swap_pages(char* va);
+void 			moveram_to_disk(struct proc* p);
+struct free_page* scfifo_alg(struct proc* p);
+void 			insert_to_disk(struct proc* p,int i,struct free_page* tmp);
+int                 pageIsInFile(int userPageVAddr, pde_t * pgdir);
+int getPageFromFile(int cr2);
+int update_memory(struct proc* p,char*va);
+struct free_page* select_page_to_remove(struct proc* p);
+int getPagePAddr(int userPageVAddr, pde_t * pgdir);
+void fixPagedOutPTE( pde_t * pgdir,int va,int walkpgdirmode);
+int get_user_bit(char* va);
+
+    
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/echo.c b/echo.c
old mode 100644
new mode 100755
diff --git a/elf.h b/elf.h
old mode 100644
new mode 100755
diff --git a/entry.S b/entry.S
old mode 100644
new mode 100755
diff --git a/entryother.S b/entryother.S
old mode 100644
new mode 100755
diff --git a/exec.c b/exec.c
old mode 100644
new mode 100755
index b40134f..6c57c1a
--- a/exec.c
+++ b/exec.c
@@ -7,6 +7,19 @@
 #include "x86.h"
 #include "elf.h"
 
+
+#ifdef NONE
+#else
+#ifdef LAPA
+static uint default_age=0xffffffff;
+#else
+static uint default_age=0;
+#endif
+#endif
+
+
+
+
 int
 exec(char *path, char **argv)
 {
@@ -19,6 +32,32 @@ exec(char *path, char **argv)
   pde_t *pgdir, *oldpgdir;
   struct proc *curproc = myproc();
 
+
+#ifndef NONE
+  int backup_pages_in_memory=curproc->pages_in_memory_counter;
+  int backup_pages_in_swapfile=curproc->pages_in_swapfile_counter;
+  uint backup_pagedout=curproc->pagedout;
+  struct free_page backup_free_page [MAX_PSYC_PAGES];
+  struct disk_info backup_disk_info [MAX_PSYC_PAGES];
+  struct free_page* backup_tail;
+  struct free_page* backup_head;
+  int backup_fault=curproc->fault_counter;
+
+  int index;
+  for(index=0;index<MAX_PSYC_PAGES;index++)
+  {
+    backup_free_page[index].va=curproc->memory_pg_arr[index].va;
+    backup_free_page[index].next=curproc->memory_pg_arr[index].next;
+    backup_free_page[index].prev=curproc->memory_pg_arr[index].prev;
+    backup_free_page[index].age=curproc->memory_pg_arr[index].age;
+    backup_disk_info[index].location=curproc->disk_pg_arr[index].location;
+    backup_disk_info[index].va=curproc->disk_pg_arr[index].va;
+  }
+  backup_head=curproc->head;
+  backup_tail=curproc->tail;
+#endif
+
+
   begin_op();
 
   if((ip = namei(path)) == 0){
@@ -38,6 +77,28 @@ exec(char *path, char **argv)
   if((pgdir = setupkvm()) == 0)
     goto bad;
 
+
+  #ifndef NONE
+
+  curproc->pages_in_memory_counter=0;
+  curproc->pages_in_swapfile_counter=0;
+  curproc->pagedout=0;
+  curproc->fault_counter=0;
+  for(index=0;index<MAX_PSYC_PAGES;index++)
+  {
+    curproc->memory_pg_arr[index].va=(char*)-1;
+    curproc->memory_pg_arr[index].next=0;
+    curproc->memory_pg_arr[index].prev=0;
+    curproc->memory_pg_arr[index].age=default_age;
+    curproc->disk_pg_arr[index].va=(char*)-1;
+    curproc->disk_pg_arr[index].location=-1;
+  }
+  curproc->head=0;
+  curproc->tail=0;
+
+
+  #endif
+
   // Load program into memory.
   sz = 0;
   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
@@ -92,13 +153,28 @@ exec(char *path, char **argv)
     if(*s == '/')
       last = s+1;
   safestrcpy(curproc->name, last, sizeof(curproc->name));
-
   // Commit to the user image.
+
+  #ifndef NONE//where we reset the swapfile
+  if(!(curproc->pid==1||(curproc->parent->pid==1)))
+  {
+
+  removeSwapFile(curproc);
+  //remove old swapfile and data
+  createSwapFile(curproc);
+}
+//create new swapfile  and data
+
+  #endif
   oldpgdir = curproc->pgdir;
   curproc->pgdir = pgdir;
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
+
+
+
+  
   switchuvm(curproc);
   freevm(oldpgdir);
   return 0;
@@ -110,5 +186,22 @@ exec(char *path, char **argv)
     iunlockput(ip);
     end_op();
   }
+  #ifndef NONE
+  curproc->pages_in_swapfile_counter=backup_pages_in_swapfile;
+  curproc->pages_in_memory_counter=backup_pages_in_memory;
+  curproc->pagedout=backup_pagedout;
+  curproc->fault_counter=backup_fault;
+  for(i=0;i<MAX_PSYC_PAGES;i++)
+  {
+    curproc->memory_pg_arr[i].va=backup_free_page[i].va;
+    curproc->memory_pg_arr[i].next=backup_free_page[i].next;
+    curproc->memory_pg_arr[i].prev=backup_free_page[i].prev;
+    curproc->memory_pg_arr[i].age=backup_free_page[i].age;
+    curproc->disk_pg_arr[i].location=backup_disk_info[i].location;
+    curproc->disk_pg_arr[i].va=backup_disk_info[i].va;
+  }
+  curproc->head=backup_head;
+  curproc->tail=backup_tail;
+  #endif
   return -1;
 }
diff --git a/fcntl.h b/fcntl.h
old mode 100644
new mode 100755
diff --git a/file.c b/file.c
old mode 100644
new mode 100755
diff --git a/file.h b/file.h
old mode 100644
new mode 100755
diff --git a/fork_test.c b/fork_test.c
new file mode 100644
index 0000000..ef53ff1
--- /dev/null
+++ b/fork_test.c
@@ -0,0 +1,36 @@
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+
+int main(int argc, char *argv[])
+
+{  int i;
+  char * arr;
+  arr = malloc (50000);
+  for (i = 0; i < 50; i++) { 
+    arr[49100+i] = 'A'; 
+    arr[45200+i] = 'B';
+  }
+  arr[49100+i] = 0; //for null terminating string...
+  arr[45200+i] = 0;
+  
+  if (fork() == 0){ //is son
+    for (i = 40; i < 50; i++) { 
+	    arr[49100+i] = 'C'; //changes last ten A's to C
+	    arr[45200+i] = 'D'; //changes last ten B's to D
+  	}
+    printf(1, "SON: %s\n",&arr[49100]); // should print AAAAA..CCC...
+    printf(1, "SON: %s\n",&arr[45200]); // should print BBBBB..DDD...
+  	printf(1,"\n");
+    free(arr);
+    exit();
+  } else { //is parent
+    wait();
+    printf(1, "PARENT: %s\n",&arr[49100]); // should print AAAAA...
+    printf(1, "PARENT: %s\n",&arr[45200]); // should print BBBBB...
+    free(arr);
+    exit();
+  }
+}
diff --git a/fork_test2.c b/fork_test2.c
new file mode 100644
index 0000000..33d0dc2
--- /dev/null
+++ b/fork_test2.c
@@ -0,0 +1,64 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+
+#define PGSIZE 4096
+#define ARR_SIZE_FORK PGSIZE*17
+#define ARR_SIZE_TEST PGSIZE*17
+
+void forkPageTest(){
+  int i;
+  char * arr;
+  int pid;
+  arr = sbrk(ARR_SIZE_FORK); //allocates 20 pages,  so 16 in RAM and 4 in the swapFile
+  for(i=0; i<ARR_SIZE_FORK; i++)    {
+    arr[i]='M';
+}
+  printf(1,"\n");
+  printf(1,"-----------------------------------\nNow forking - n-----------------------------------\n");
+  sleep(20);
+  sleep(20);
+  printf(1,"FORK\n");
+  //Child - change array to C's and print some
+  if((pid=fork()) == 0){  
+    printf(1,"-----------------------------------\nChild is going to sleep  -\n-----------------------------------\n");
+    sleep(300);
+    sleep(20);
+    sleep(20);
+        printf(1,"-----------------------------------\nChild done sleeping -\n-----------------------------------\n");
+
+    int j;
+    for(j=0; j<ARR_SIZE_FORK/300; j++){
+      arr[j]='C'; //change the whole array for the child   
+      if(j==ARR_SIZE_FORK-1)
+        arr[j]='x';    
+    }
+    printf(1,"Child -\n-------\n");
+    for(j=0; j<ARR_SIZE_FORK/300; j++){
+      if(j % 1000 == 0 || j==ARR_SIZE_FORK-1)
+        printf(1,"%c",arr[j]);
+    }
+    printf(1,"\n\n");
+    exit();
+  }
+  //Parent- change some array letters to 'P's and print some.
+  else{
+    for(i=0; i<ARR_SIZE_FORK/2; i++){
+      arr[i]='P'; //change the some array for the Parent       
+      if(i==ARR_SIZE_TEST/2-1)
+        arr[i]='X';    
+    }
+    printf(1,"Parent -\n-------\n");
+    for(i=0; i<ARR_SIZE_FORK; i++){
+      if(i % 1000 == 0|| i==ARR_SIZE_TEST-1)
+        printf(1,"%c",arr[i]);
+    }
+    printf(1,"\n\n");
+    sleep(30);
+    wait();
+    printf(1,"parent exiting.\n");
+    exit();
+  }
+
+}
\ No newline at end of file
diff --git a/forktest.c b/forktest.c
old mode 100644
new mode 100755
diff --git a/fs.c b/fs.c
old mode 100644
new mode 100755
index 3cb3f8e..ded3e7d
--- a/fs.c
+++ b/fs.c
@@ -811,3 +811,17 @@ readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
 
 
 
+void copySwapFile(struct proc* fromP, struct proc* toP){
+  if (fromP->pid < 3)
+    return;
+  char buff[PGSIZE];
+  int i;
+  for (i = 0; i < 16; i++){
+    if (fromP->disk_pg_arr[i].va !=(char*)-1){
+      if (readFromSwapFile(fromP, buff, PGSIZE*i, PGSIZE) != PGSIZE)
+        panic("CopySwapFile error");
+      if (writeToSwapFile(toP, buff, PGSIZE*i, PGSIZE) != PGSIZE)
+        panic("CopySwapFile error");
+    }
+  }
+}
diff --git a/fs.h b/fs.h
old mode 100644
new mode 100755
diff --git a/gdbutil b/gdbutil
old mode 100644
new mode 100755
diff --git a/grep.c b/grep.c
old mode 100644
new mode 100755
diff --git a/ide.c b/ide.c
old mode 100644
new mode 100755
diff --git a/init.c b/init.c
old mode 100644
new mode 100755
diff --git a/initcode.S b/initcode.S
old mode 100644
new mode 100755
diff --git a/ioapic.c b/ioapic.c
old mode 100644
new mode 100755
diff --git a/kalloc.c b/kalloc.c
old mode 100644
new mode 100755
index 14cd4f4..ac295bf
--- a/kalloc.c
+++ b/kalloc.c
@@ -13,6 +13,8 @@ void freerange(void *vstart, void *vend);
 extern char end[]; // first address after kernel loaded from ELF file
                    // defined by the kernel linker script in kernel.ld
 
+static int page_counter=0;
+static int total_free_pages=0;
 struct run {
   struct run *next;
 };
@@ -23,6 +25,18 @@ struct {
   struct run *freelist;
 } kmem;
 
+int getfreepages(){
+  return page_counter;
+}
+
+int getTotalPageskernel(){
+  return PGROUNDDOWN(PHYSTOP-V2P(end))/PGSIZE;
+}
+int getTotalfreePages()
+  {
+    return total_free_pages;
+  }
+
 // Initialization happens in two phases.
 // 1. main() calls kinit1() while still using entrypgdir to place just
 // the pages mapped by entrypgdir on free list.
@@ -34,6 +48,7 @@ kinit1(void *vstart, void *vend)
   initlock(&kmem.lock, "kmem");
   kmem.use_lock = 0;
   freerange(vstart, vend);
+  total_free_pages+= (PGROUNDDOWN((uint)vend) - PGROUNDUP((uint)vstart))/PGSIZE;
 }
 
 void
@@ -41,6 +56,7 @@ kinit2(void *vstart, void *vend)
 {
   freerange(vstart, vend);
   kmem.use_lock = 1;
+  total_free_pages+= (PGROUNDDOWN((uint)vend) - PGROUNDUP((uint)vstart))/PGSIZE;
 }
 
 void
@@ -61,6 +77,7 @@ kfree(char *v)
 {
   struct run *r;
 
+
   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
     panic("kfree");
 
@@ -70,6 +87,7 @@ kfree(char *v)
   if(kmem.use_lock)
     acquire(&kmem.lock);
   r = (struct run*)v;
+  page_counter++;
   r->next = kmem.freelist;
   kmem.freelist = r;
   if(kmem.use_lock)
@@ -83,10 +101,10 @@ char*
 kalloc(void)
 {
   struct run *r;
-
   if(kmem.use_lock)
     acquire(&kmem.lock);
   r = kmem.freelist;
+  page_counter--;
   if(r)
     kmem.freelist = r->next;
   if(kmem.use_lock)
diff --git a/kbd.c b/kbd.c
old mode 100644
new mode 100755
diff --git a/kbd.h b/kbd.h
old mode 100644
new mode 100755
diff --git a/kernel.ld b/kernel.ld
old mode 100644
new mode 100755
diff --git a/kill.c b/kill.c
old mode 100644
new mode 100755
diff --git a/lapic.c b/lapic.c
old mode 100644
new mode 100755
diff --git a/linear_test.c b/linear_test.c
new file mode 100644
index 0000000..f848d3d
--- /dev/null
+++ b/linear_test.c
@@ -0,0 +1,32 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+
+#define PGSIZE 4096
+#define  ARR_SIZE PGSIZE*20
+
+
+int main(int argc, char *argv[]){
+  
+  printf(1,"linear test main\n");
+
+  char * arr;
+  int i;
+  printf(1,"allocation with sbrk\n");
+  arr = sbrk(ARR_SIZE); //asking for 20 pages so some will be in the swapfile
+  printf(1,"going over the array putting B char in every even place and A in odd place\n");
+  for(i=0; i<ARR_SIZE; i++){
+    sleep(0);
+    if(i%2==0)
+    arr[i]='B';
+	else
+	arr[i]='A';
+    if((i % (PGSIZE/2)) == 0){  //print every PGSIZE/2 digits should prints only B
+      printf(1,"%c",arr[i]);
+    }
+  }
+  printf(1,"\n\n");
+  sbrk(-ARR_SIZE);//deallocating the memory we asked for only program memory should stay
+  exit();
+}
\ No newline at end of file
diff --git a/ln.c b/ln.c
old mode 100644
new mode 100755
diff --git a/log.c b/log.c
old mode 100644
new mode 100755
diff --git a/ls.c b/ls.c
old mode 100644
new mode 100755
diff --git a/main.c b/main.c
old mode 100644
new mode 100755
diff --git a/memide.c b/memide.c
old mode 100644
new mode 100755
diff --git a/memlayout.h b/memlayout.h
old mode 100644
new mode 100755
diff --git a/mkdir.c b/mkdir.c
old mode 100644
new mode 100755
diff --git a/mkfs.c b/mkfs.c
old mode 100644
new mode 100755
diff --git a/mmu.h b/mmu.h
old mode 100644
new mode 100755
index 7b63db0..0621b9b
--- a/mmu.h
+++ b/mmu.h
@@ -141,7 +141,7 @@ struct segdesc {
 #define PTE_D           0x040   // Dirty
 #define PTE_PS          0x080   // Page Size
 #define PTE_MBZ         0x180   // Bits must be zero
-
+#define PTE_PG          0x200   //Paged out to secondary storage 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
diff --git a/mp.c b/mp.c
old mode 100644
new mode 100755
diff --git a/mp.h b/mp.h
old mode 100644
new mode 100755
diff --git a/myMemTest.c b/myMemTest.c
new file mode 100755
index 0000000..77203a3
--- /dev/null
+++ b/myMemTest.c
@@ -0,0 +1,102 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+
+#define PGSIZE 4096
+#define  ARR_SIZE PGSIZE*15
+
+#define test_len 40
+
+static unsigned int 
+x=123456789,y=362436069,z=521288629,w=88675123,v=886756453; 
+      /* replace defaults with five random seed values in calling program */ 
+unsigned int xorshift(void) // taken from https://mathoverflow.net/questions/29494/pseudo-random-number-generation-algorithms for get random code
+{unsigned int t; 
+ t=(x^(x>>7)); x=y; y=z; z=w; w=v; 
+ v=(v^(v<<6))^(t^(t<<13)); return (y+y+1)*v;}
+
+
+
+
+int main(int argc, char *argv[])
+{
+	
+
+
+  printf(1,"random test main\n");
+  char * arr;
+  int i;
+  int tmp=0;
+  printf(1,"allocation with malloc\n");
+  arr = sbrk(ARR_SIZE); //asking for 20 pages so some will be in the swapfile
+  printf(1,"going over the array putting B char in random placesand D in half pagesize interval around the random place\n");
+  for(i=0; i<test_len; i++){
+    printf(1,"i=%d\n",i);
+    tmp=xorshift()%ARR_SIZE;
+    arr[tmp]='A';
+    int j=PGSIZE/4;
+    while(j>0)
+    {
+      arr[(tmp+j)%ARR_SIZE]='B';
+      j--;
+    }
+    j=-1*PGSIZE/4;
+    while(j<0)
+    {
+      int k=tmp+j;
+      if(k<0)
+      {
+        k=0;
+      }
+    arr[(k)%ARR_SIZE]='D';
+    j++;
+    }
+    sleep(0);
+}
+  int j=PGSIZE/4;
+  printf(1,"testing last assigment should get  B A\n");
+  printf(1,"%c \n",arr[(tmp+j)%ARR_SIZE]);
+  printf(1,"%c\n",arr[tmp]);
+  printf(1,"\n\n");
+  sbrk(-ARR_SIZE);//deallocating the memory we asked for only program memory should stay
+  printf(1,"random TEST DONE\n");
+
+
+char * argv2[]={"fork_test",0};
+char * argv3[]={"linear_test",0};
+char * argv4[]={"fork_test2",0};
+
+ int pid=fork();
+if(pid==0)
+
+{
+	exec("fork_test",argv2);
+	exit();
+}
+ sleep(199);
+ wait();//wait
+ printf(1,"forktest1 done\n");
+
+pid=fork();
+
+if(pid==0)//3rd test
+{
+//	sleep(199);
+	exec("linear_test",argv3);
+	exit();
+}
+
+sleep(199);
+wait();
+printf(1,"linear_test done\n");
+pid=fork();
+if(pid==0)//last test
+{
+	exec("fork_test2",argv4);
+}
+sleep(600);
+wait();
+exit();
+}
+
diff --git a/param.h b/param.h
old mode 100644
new mode 100755
diff --git a/picirq.c b/picirq.c
old mode 100644
new mode 100755
diff --git a/pipe.c b/pipe.c
old mode 100644
new mode 100755
diff --git a/printf.c b/printf.c
old mode 100644
new mode 100755
diff --git a/proc.c b/proc.c
old mode 100644
new mode 100755
index 806b1b1..8a70d02
--- a/proc.c
+++ b/proc.c
@@ -7,6 +7,18 @@
 #include "proc.h"
 #include "spinlock.h"
 
+
+
+#ifdef NONE
+#else
+#ifdef LAPA
+static uint default_age=0xffffffff;
+#else
+static uint default_age=0;
+#endif
+#endif
+
+
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
@@ -71,7 +83,7 @@ myproc(void) {
 // state required to run in the kernel.
 // Otherwise return 0.
 static struct proc*
-allocproc(void)
+allocproc()
 {
   struct proc *p;
   char *sp;
@@ -106,12 +118,29 @@ found:
   // which returns to trapret.
   sp -= 4;
   *(uint*)sp = (uint)trapret;
-
   sp -= sizeof *p->context;
   p->context = (struct context*)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
+#ifndef NONE
+  p->pagedout=0;
+  p->pages_in_memory_counter=0;
+  p->pages_in_swapfile_counter=0;
+  p->fault_counter=0;
+  int i=0;
+  for(i=0;i<MAX_PSYC_PAGES;i++)
+  {
+    p->disk_pg_arr[i].va=(char*)-1;//0xFFFFFFFF
+    p->disk_pg_arr[i].location=-1;
+    p->memory_pg_arr[i].va=(char*)-1;//0XFFFFFFFF
+    p->memory_pg_arr[i].age=default_age;
+    p->memory_pg_arr[i].next=0;
+    p->memory_pg_arr[i].prev=0;
+  }
+  p->head=0;
+  p->tail=0;
+#endif
   return p;
 }
 
@@ -138,7 +167,6 @@ userinit(void)
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
   p->tf->eip = 0;  // beginning of initcode.S
-
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
@@ -147,7 +175,6 @@ userinit(void)
   // writes to be visible, and the lock is also needed
   // because the assignment might not be atomic.
   acquire(&ptable.lock);
-
   p->state = RUNNABLE;
 
   release(&ptable.lock);
@@ -187,7 +214,7 @@ fork(void)
   // Allocate process.
   if((np = allocproc()) == 0){
     return -1;
-  }
+}
 
   // Copy process state from proc.
   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
@@ -210,7 +237,65 @@ fork(void)
 
   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
 
-  pid = np->pid;
+   pid = np->pid;
+
+#ifndef NONE//copy stuff from parent to son;
+  np->pages_in_swapfile_counter=curproc->pages_in_swapfile_counter;
+  np->pages_in_memory_counter=curproc->pages_in_memory_counter;
+  //cprintf("np->page in swapfile =%d \n",np->pages_in_swapfile_counter);
+  np->pagedout=0;
+  np->fault_counter=0;
+  for(i=0;i<MAX_PSYC_PAGES;i++)
+  {
+    np->memory_pg_arr[i].va=curproc->memory_pg_arr[i].va;
+    np->memory_pg_arr[i].age=curproc->memory_pg_arr[i].age;
+    //np->memory_pg_arr[i].next=curproc->memory_pg_arr[i].next;
+    //np->memory_pg_arr[i].prev=curproc->memory_pg_arr[i].prev;
+    np->disk_pg_arr[i].va=curproc->disk_pg_arr[i].va;
+    np->disk_pg_arr[i].location=curproc->disk_pg_arr[i].location;
+
+  }
+
+int j;
+  for(i=0;i<MAX_PSYC_PAGES;i++)
+  {
+    for(j=0;j<MAX_PSYC_PAGES;++j)
+    {
+//      if(memory_pg_arr[i].next!=0)
+      if(np->memory_pg_arr[j].va==curproc->memory_pg_arr[i].next->va)
+        np->memory_pg_arr[i].next=&np->memory_pg_arr[i];
+    
+      if(np->memory_pg_arr[j].va==curproc->memory_pg_arr[i].prev->va)
+        np->memory_pg_arr[i].prev=&np->memory_pg_arr[i];
+    }
+
+  }
+for(i=0;i<MAX_PSYC_PAGES;i++)
+{
+  if (curproc->head->va ==np->memory_pg_arr[i].va)
+  {
+      np->head=&np->memory_pg_arr[i];
+  }
+
+ if (curproc->tail->va ==np->memory_pg_arr[i].va)
+{      np->tail=&np->memory_pg_arr[i];
+}
+
+}
+
+#ifndef NONE
+  if(curproc->pid!=1)//if my parent is init
+  {
+    createSwapFile(np);
+    copySwapFile(curproc,np);
+  }
+#endif
+
+
+ // np->tail=curproc->tail;
+#endif
+
+
 
   acquire(&ptable.lock);
 
@@ -230,10 +315,32 @@ exit(void)
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
-
   if(curproc == initproc)
-    panic("init exiting");
+   panic("init exiting");
+  
+  
+      #if TRUE
+   acquire(&ptable.lock);
+
+  procdump_proc(myproc());
+  release(&ptable.lock);
 
+  #endif
+    #ifndef NONE
+     if(!(curproc->pid==1||curproc->parent->pid==1))//NOT shell or init
+{
+    if (removeSwapFile(curproc) != 0)
+     {
+    panic("failed in delete the swap file at exit\n");
+     }
+     }
+
+
+    #endif
+
+
+
+  
   // Close all open files.
   for(fd = 0; fd < NOFILE; fd++){
     if(curproc->ofile[fd]){
@@ -242,6 +349,7 @@ exit(void)
     }
   }
 
+
   begin_op();
   iput(curproc->cwd);
   end_op();
@@ -262,7 +370,8 @@ exit(void)
   }
 
   // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
+  curproc->state = ZOMBIE; 
+ 
   sched();
   panic("zombie exit");
 }
@@ -311,6 +420,57 @@ wait(void)
   }
 }
 
+
+
+
+pte_t *
+proc_walkpagedir(pde_t *pgdir, const void *va, int alloc)
+{
+  pde_t *pde;
+  pte_t *pgtab;
+
+  pde = &pgdir[PDX(va)];
+  if(*pde & PTE_P){
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+  } else {
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+      return 0;
+    // Make sure all those PTE_P bits are zero.
+    memset(pgtab, 0, PGSIZE);
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+  }
+  return &pgtab[PTX(va)];
+}
+
+
+ int updateAccessBit_proc(char *va,struct proc* p)
+{
+  uint accessed;
+  pte_t *pte = proc_walkpagedir(p->pgdir, (void*)va, 0);
+  if (!pte){
+      cprintf("pid=%d\n",p->pid);
+    panic("updateAccessBi111t: pte is empty");
+  }
+  if(!*pte)
+  {
+    return -2;
+  }
+  accessed = (*pte) & PTE_A;
+  (*pte) &= ~PTE_A;
+  if(accessed==0)
+  {
+      return 0;
+    }
+    else
+    {
+        return 1;
+    }
+}
+
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -325,7 +485,15 @@ scheduler(void)
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
+#ifndef NONE
+#ifndef SCFIFO
+  int i=0;
+#endif
+#endif
+#ifdef AQ
+  uint tmp_age;
+  char* tmp_va=0;
+#endif
   for(;;){
     // Enable interrupts on this processor.
     sti();
@@ -344,6 +512,62 @@ scheduler(void)
       p->state = RUNNING;
 
       swtch(&(c->scheduler), p->context);
+      #ifndef NONE
+      #ifndef SCFIFO
+      #ifndef AQ
+      if(!(p->pid==1||p->parent->pid==1))
+      {
+        for(i=0;i<MAX_PSYC_PAGES;i++)
+        {
+            if(p->memory_pg_arr[i].va!=(char*)-1)
+            {
+            p->memory_pg_arr[i].age=p->memory_pg_arr[i].age>>1;
+            int tmp=updateAccessBit_proc(p->memory_pg_arr[i].va,p)==1;
+            if(tmp==1)
+            p->memory_pg_arr[i].age=p->memory_pg_arr[i].age|(1<<31);
+            }
+        }
+      }
+      #endif
+      #endif
+      #endif
+      #ifdef AQ
+      if(!(p->pid==1||p->parent->pid==1))
+      {
+        for(i=0;i<MAX_PSYC_PAGES;i++)
+        {
+          if(p->memory_pg_arr[i].va!=(char*)-1)
+          {
+            int tmp=updateAccessBit_proc(p->memory_pg_arr[i].va,p)==1;
+            if(tmp==1)
+            {
+              p->memory_pg_arr[i].age=1;
+            }
+            else
+            {
+              p->memory_pg_arr[i].age=0;
+            }          
+          }
+        }
+        struct free_page* curpage=p->head;//remove from tail
+        while(curpage!=0)
+        {
+          if(curpage->prev != 0)
+          {
+            if(curpage->prev->age==0&&curpage->age==1)
+            {
+              tmp_va=curpage->prev->va;
+              curpage->prev->va=curpage->va;
+              curpage->va=tmp_va;
+              tmp_age=curpage->age;
+              curpage->age=curpage->prev->age;
+              curpage->prev->age=tmp_age;
+            }
+          }
+          curpage=curpage->next;
+        }
+      }
+      #endif
       switchkvm();
 
       // Process is done running for now.
@@ -500,6 +724,96 @@ kill(int pid)
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
+
+
+
+void
+procdump_proc(struct proc* p)
+{
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [EMBRYO]    "embryo",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  int i;
+  char *state;
+  uint pc[10];
+  uint page_counter;
+  
+    if(p->state == UNUSED)
+      return;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+    page_counter=p->pages_in_memory_counter+p->pages_in_swapfile_counter;
+    cprintf(" %d %s ", p->pid, state);
+    cprintf("%d  %d  %d  %d  %s  ",page_counter,p->pages_in_swapfile_counter,p->fault_counter,p->pagedout,p->name);
+   // cprintf("%d %s %s",p->pid,state,p->name);
+    //<field 1><field 2><allocated memory pages><paged out><page faults><total number of paged out><field set 3> 
+    //  cprintf("%d  %s %d %d %d %d %s",p->pid,state,page_counter,p->pages_in_swapfile_counter,p->fault_counter,p->pagedout,p->name);
+    //cprintf("%d %s %d %d %d %s", p->pid,state,page_counter,p->pages_in_swapfile_counter,p->fault_counter,p->pagedout,p->name);
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+      cprintf("%d / %d free pages in the system\n", getfreepages(),getTotalfreePages());
+}
+
+
+
+
+
+
+#ifdef TRUE
+void
+procdump(void)
+{
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [EMBRYO]    "embryo",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if(p->state == UNUSED)
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+    //cprintf("\npid:%d state:%s\n", p->pid, state);
+    //cprintf("allocated memory pages:%d paged out:%d page faults:%d total number of paged out:%d\n name:%s\n",page_counter,p->pages_in_swapfile_counter,p->fault_counter,p->pagedout,p->name);
+    cprintf(" %d %s ", p->pid, state);
+    cprintf("%d  %d  %d  %d  %s  ",(p->pages_in_swapfile_counter+p->pages_in_memory_counter),p->pages_in_swapfile_counter,p->fault_counter,p->pagedout,p->name);
+  //  cprintf("%d %s %s",p->pid,state,p->name);
+    //<field 1><field 2><allocated memory pages><paged out><page faults><total number of paged out><field set 3> 
+    //  cprintf("%d  %s %d %d %d %d %s",p->pid,state,page_counter,p->pages_in_swapfile_counter,p->fault_counter,p->pagedout,p->name);
+    //cprintf("%d %s %d %d %d %s", p->pid,state,page_counter,p->pages_in_swapfile_counter,p->fault_counter,p->pagedout,p->name);
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+    //<current free pages>/ <total free pages>free pages in the system
+    //cprintf("free pages =%d totalfree page =%d \n",getfreepages(),getTotalfreePages());
+  }
+      cprintf("%d / %d free pages in the system\n", getfreepages(),getTotalfreePages());
+}
+#else//is none
 void
 procdump(void)
 {
@@ -532,3 +846,5 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+#endif
diff --git a/proc.h b/proc.h
old mode 100644
new mode 100755
index bd4f91d..45590d0
--- a/proc.h
+++ b/proc.h
@@ -1,3 +1,7 @@
+
+#define MAX_PSYC_PAGES 16
+#define MAX_TOTAL_PAGES 32
+
 // Per-CPU state
 struct cpu {
   uchar apicid;                // Local APIC ID
@@ -34,6 +38,17 @@ struct context {
 
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
+struct disk_info{
+  char* va;
+  int location;//isnt needed
+};
+struct free_page{
+  struct free_page* next;
+  struct free_page* prev;
+  char* va;
+  uint age;
+};
+
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
@@ -52,6 +67,15 @@ struct proc {
 
   //Swap file. must initiate with create swap file
   struct file *swapFile;      //page file
+  int 	 pages_in_memory_counter;	  //counter for pages that are located in memory
+  int 	 pages_in_swapfile_counter;	  //counter ofr pages that are located in the swapfile
+  uint   pagedout;
+  uint fault_counter;
+  struct disk_info disk_pg_arr [MAX_PSYC_PAGES];//data about pages in disk-swapfile
+  struct free_page memory_pg_arr [MAX_PSYC_PAGES];//data about pages in physical ram
+  struct free_page* head;
+  struct free_page* tail;
+  int dirty;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/rm.c b/rm.c
old mode 100644
new mode 100755
diff --git a/runoff.list b/runoff.list
old mode 100644
new mode 100755
diff --git a/runoff.spec b/runoff.spec
old mode 100644
new mode 100755
diff --git a/sh.c b/sh.c
old mode 100644
new mode 100755
diff --git a/sleep1.p b/sleep1.p
old mode 100644
new mode 100755
diff --git a/sleeplock.c b/sleeplock.c
old mode 100644
new mode 100755
diff --git a/sleeplock.h b/sleeplock.h
old mode 100644
new mode 100755
diff --git a/spinlock.c b/spinlock.c
old mode 100644
new mode 100755
index 9120bf2..0ea26e8
--- a/spinlock.c
+++ b/spinlock.c
@@ -26,7 +26,9 @@ acquire(struct spinlock *lk)
 {
   pushcli(); // disable interrupts to avoid deadlock.
   if(holding(lk))
+    {cprintf(" %s \n",lk->name);
     panic("acquire");
+  }
 
   // The xchg is atomic.
   while(xchg(&lk->locked, 1) != 0)
diff --git a/spinlock.h b/spinlock.h
old mode 100644
new mode 100755
diff --git a/stat.h b/stat.h
old mode 100644
new mode 100755
diff --git a/stressfs.c b/stressfs.c
old mode 100644
new mode 100755
diff --git a/string.c b/string.c
old mode 100644
new mode 100755
diff --git a/swtch.S b/swtch.S
old mode 100644
new mode 100755
diff --git a/symlink.patch b/symlink.patch
old mode 100644
new mode 100755
diff --git a/syscall.c b/syscall.c
old mode 100644
new mode 100755
diff --git a/syscall.h b/syscall.h
old mode 100644
new mode 100755
diff --git a/sysfile.c b/sysfile.c
old mode 100644
new mode 100755
diff --git a/sysproc.c b/sysproc.c
old mode 100644
new mode 100755
diff --git a/toc.ftr b/toc.ftr
old mode 100644
new mode 100755
diff --git a/toc.hdr b/toc.hdr
old mode 100644
new mode 100755
diff --git a/trap.c b/trap.c
old mode 100644
new mode 100755
index 41c66eb..e78fb01
--- a/trap.c
+++ b/trap.c
@@ -26,6 +26,36 @@ tvinit(void)
   initlock(&tickslock, "time");
 }
 
+
+
+
+
+
+pte_t *
+callwalkpgdir(pde_t *pgdir, const void *va, int alloc)
+{
+  pde_t *pde;
+  pte_t *pgtab;
+
+  pde = &pgdir[PDX(va)];
+  if(*pde & PTE_P){
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+  } else {
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+      return 0;
+    // Make sure all those PTE_P bits are zero.
+    memset(pgtab, 0, PGSIZE);
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+  }
+  return &pgtab[PTX(va)];
+}
+
+
+
+
 void
 idtinit(void)
 {
@@ -36,6 +66,7 @@ idtinit(void)
 void
 trap(struct trapframe *tf)
 {
+  //int i;
   if(tf->trapno == T_SYSCALL){
     if(myproc()->killed)
       exit();
@@ -77,6 +108,18 @@ trap(struct trapframe *tf)
             cpuid(), tf->cs, tf->eip);
     lapiceoi();
     break;
+#ifndef NONE
+  case T_PGFLT:
+  {
+    int fault=rcr2();
+        if (myproc() != 0 && (tf->cs&3) == 3 &&pageIsInFile(fault, myproc()->pgdir)){
+      if (getPageFromFile(fault)){
+        myproc()->fault_counter++;
+        break;
+    }
+    }
+ }
+ #endif
 
   //PAGEBREAK: 13
   default:
diff --git a/trapasm.S b/trapasm.S
old mode 100644
new mode 100755
diff --git a/traps.h b/traps.h
old mode 100644
new mode 100755
diff --git a/types.h b/types.h
old mode 100644
new mode 100755
diff --git a/uart.c b/uart.c
old mode 100644
new mode 100755
diff --git a/ulib.c b/ulib.c
old mode 100644
new mode 100755
diff --git a/umalloc.c b/umalloc.c
old mode 100644
new mode 100755
diff --git a/user.h b/user.h
old mode 100644
new mode 100755
diff --git a/usertests.c b/usertests.c
old mode 100644
new mode 100755
diff --git a/usys.S b/usys.S
old mode 100644
new mode 100755
diff --git a/vm.c b/vm.c
old mode 100644
new mode 100755
index 3f71b6a..7e20604
--- a/vm.c
+++ b/vm.c
@@ -8,8 +8,19 @@
 #include "elf.h"
 
 extern char data[];  // defined by kernel.ld
-pde_t *kpgdir;  // for use in scheduler()
+pde_t *kpgdir;  // for use in scheduler()"not found va trap14\n")
 
+
+#ifdef NONE
+static uint default_age=0;
+#else
+#ifdef LAPA
+static uint default_age=0xffffffff;
+#else
+static uint default_age=0;
+#endif
+#endif
+char* zero_page[PGSIZE]={0};
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
 void
@@ -29,6 +40,105 @@ seginit(void)
   lgdt(c->gdt, sizeof(c->gdt));
 }
 
+
+int findRamIndex(struct proc*p,char* item)
+{
+    int i;
+        for(i=0;i<MAX_PSYC_PAGES;i++)
+        {
+            if(p->memory_pg_arr[i].va==(char*)-1)
+            {
+                return i;
+            }
+        }
+        return -1;
+}
+
+int readPageFromFile(struct proc* p,int user_address,char* buffer)
+{
+    int i;
+    int read=-1;
+    for(i=0;i<MAX_PSYC_PAGES;i++)
+    {
+        if(p->disk_pg_arr[i].va==(char*)user_address)
+        {
+            read=readFromSwapFile(p,buffer,i*PGSIZE,PGSIZE);
+            p->disk_pg_arr[i].va=(char*)-1;
+            p->pages_in_swapfile_counter--;
+            if(read==-1)
+            {
+              panic("failled to read from  swapfile\n");
+                return-1;//error
+            }
+            update_memory(p,(char*)user_address);
+            return read;
+        }
+    }
+    return -2;//given user_address wasnt on disk
+}
+
+int writePageToFile(struct proc * p, int userPageVAddr, pde_t *pgdir)
+{
+    int i;
+    for(i=0;i<MAX_PSYC_PAGES;i++)
+    {
+        if(p->disk_pg_arr[i].va==(char*)-1)
+        {
+            int res=writeToSwapFile(p,(char*)userPageVAddr,PGSIZE*i,PGSIZE);
+            if(res==-1)
+            {
+                return -1;
+            }
+            p->disk_pg_arr[i].va=(char*)userPageVAddr;
+            p->pages_in_swapfile_counter++;
+            p->pagedout++;
+            return res;
+        }   
+    }
+    return -2;//disk was full
+}
+
+static char buff[PGSIZE]; //buffer used to store swapped page in getPageFromFile method
+
+
+
+int getPageFromFile(int fault_address)
+{
+    struct proc* p=myproc();
+    if(p==0)
+    {return 0;}
+    int userPageVAddr = PGROUNDDOWN(fault_address);
+    char * newPg = kalloc();
+    memset(newPg, 0, PGSIZE);
+    lcr3(V2P(myproc()->pgdir)); //refresh CR3 register
+    if(p->pages_in_memory_counter>=MAX_PSYC_PAGES)//swap needed
+    {
+    char* va=0;
+    struct free_page* to_remove=select_page_to_remove(p);//select based on defined paging algorithem
+    va=to_remove->va;
+    to_remove->va=(char*)-1;
+    p->pages_in_memory_counter--;
+    fixPagedInPTE(userPageVAddr, V2P(newPg), p->pgdir);//update pte of useraddress
+    readPageFromFile(p,userPageVAddr, buff);//add to memory datastructre inside the function
+    int outPagePAddr = getPagePAddr((int)va,p->pgdir);//get page virtual address wtithout the offset of given vadress
+    memmove(newPg, buff, PGSIZE);
+    writePageToFile(p, (int)va, p->pgdir);
+    fixPagedOutPTE(p->pgdir,(int)va,0);
+    char *v = P2V(outPagePAddr);
+    kfree(v); //free swapped page
+  return 1;
+    }
+    else//swap isnt needed
+    {
+    fixPagedInPTE(userPageVAddr, V2P(newPg), p->pgdir);
+    readPageFromFile(p,userPageVAddr, (char*)userPageVAddr);
+   return 1;
+    }
+    return 0;
+}
+
+
+
 // Return the address of the PTE in page table pgdir
 // that corresponds to virtual address va.  If alloc!=0,
 // create any required page table pages.
@@ -54,6 +164,30 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
   return &pgtab[PTX(va)];
 }
 
+int getPagePAddr(int userPageVAddr, pde_t * pgdir){
+  pte_t *pte;
+  pte = walkpgdir(pgdir, (int*)userPageVAddr, 0);
+  if(!pte) //uninitialized page table
+    return -1;
+  return PTE_ADDR(*pte);
+}
+
+
+void fixPagedInPTE(int userPageVAddr, int pagePAddr, pde_t * pgdir){
+  pte_t *pte;
+  pte = walkpgdir(pgdir, (int*)userPageVAddr, 0);
+  if (!pte)
+    panic("PTE of swapped page is missing");
+  if (*pte & PTE_P)
+  	panic("REMAP!");
+  *pte |= PTE_P | PTE_W | PTE_U;      //Turn on needed bits
+  *pte &= ~PTE_PG;    //Turn off inFile bit
+  *pte |= pagePAddr;  //Map PTE to the new Page
+  lcr3(V2P(myproc()->pgdir)); //refresh CR3 register
+}
+
+
+
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
@@ -93,7 +227,7 @@ mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 //   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
 //                for the kernel's instructions and r/o data
 //   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
-//                                  rw data + free physical memory
+//                                  rw data +int 
 //   0xfe000000..0: mapped direct (devices such as ioapic)
 //
 // The kernel allocates physical memory for its heap and for user memory
@@ -114,6 +248,21 @@ static struct kmap {
  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
 };
 
+
+void fixPagedOutPTE( pde_t * pgdir,int va,int walkpgdirmode)
+{
+  pte_t *pte;
+  pte = walkpgdir(pgdir,(char*)va, walkpgdirmode);
+  if (!pte)
+    panic("PTE of swapped page is missing");
+  *pte |= PTE_PG;//add pg flag to the page
+  *pte &= ~PTE_P;//remove present flag
+  *pte &= PTE_FLAGS(*pte); //clear junk physical address
+  lcr3(V2P(myproc()->pgdir)); //refresh CR3 register
+}
+
+
+
 // Set up kernel part of a page table.
 pde_t*
 setupkvm(void)
@@ -199,7 +348,6 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
 {
   uint i, pa, n;
   pte_t *pte;
-
   if((uint) addr % PGSIZE != 0)
     panic("loaduvm: addr must be page aligned");
   for(i = 0; i < sz; i += PGSIZE){
@@ -216,11 +364,320 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
   return 0;
 }
 
+
+
+int update_memoryscfifo(struct proc* p ,char* va)
+{
+      if(((p->head==0)&&(p->tail!=0))||((p->head!=0)&&(p->tail==0)))
+      {
+          panic("structure is wrong tail is  ");//toremove this test
+      }
+           if(p->head!=0)
+      {
+          if((p->head->prev)!=0)
+          {
+            panic("queue head got prev pointer\n");
+          }
+      }  
+  int i;
+  for(i=0;i<MAX_PSYC_PAGES;i++)
+  {
+      if(p->memory_pg_arr[i].va==(char*)-1)
+      {
+          p->memory_pg_arr[i].va=(char*)va;
+          p->memory_pg_arr[i].age=default_age;
+          p->pages_in_memory_counter++;
+        if((p->head==0)&&(p->tail==0))
+        {
+          p->memory_pg_arr[i].next=0;
+          p->memory_pg_arr[i].prev=0;
+          p->head=&p->memory_pg_arr[i];
+          p->tail=&p->memory_pg_arr[i];
+          return i;
+        } 
+       if(p->tail!=0)
+       {
+          if((p->tail->next)!=0)
+          {
+            panic("queue tail got next pointer\n");//to remove this test
+          }//extra check for error handling            
+          p->tail->next=&(p->memory_pg_arr[i]); 
+          p->tail=&(p->memory_pg_arr[i]);
+          p->tail->next=0;
+          return i;
+        }
+      }
+  }
+  panic("no empty place in memory scfifo\n");
+  //update memory datasture
+}
+
+int update_memoryaq(struct proc* p,char* va)
+{
+
+        if(((p->head==0)&&(p->tail!=0))||((p->head!=0)&&(p->tail==0)))
+      {
+          panic("structure is wrong tail is  ");//toremove this test
+      }
+           if(p->head!=0)
+      {
+          if((p->head->prev)!=0)
+          {
+            panic("queue head got prev pointer\n");
+          }
+      }  
+  int i;
+  for(i=0;i<MAX_PSYC_PAGES;i++)
+  {
+      if(p->memory_pg_arr[i].va==(char*)-1)
+      {
+          p->memory_pg_arr[i].va=(char*)va;
+          p->memory_pg_arr[i].age=default_age;
+          p->pages_in_memory_counter++;
+          p->memory_pg_arr[i].next=0;
+          p->memory_pg_arr[i].prev=0;
+
+        if((p->head==0)&&(p->tail==0))
+        {
+          p->head=&p->memory_pg_arr[i];
+          p->tail=&p->memory_pg_arr[i];
+          return i;
+        }
+        else
+        {
+            p->head->prev=&p->memory_pg_arr[i];
+            p->head=&p->memory_pg_arr[i];
+            return i;     
+      }
+    }
+  }
+           
+  panic("no empty place in memory aq\n");
+  //update memory datasture
+}
+
+
+
+
+
+struct free_page * nfu_alg(struct proc* p)
+{
+    int i=0;
+    int min_index=-1;
+    int min_age=-1;
+    for(i=0;i<MAX_PSYC_PAGES;i++)
+    {
+      if(p->memory_pg_arr[i].va!=(char*)-1)
+      {
+        if(min_index==-1)
+        {
+            min_index=i;
+            min_age=p->memory_pg_arr[i].age;
+        }
+        else
+        {
+            if(p->memory_pg_arr[i].age<min_age)
+            {
+                min_age=p->memory_pg_arr[i].age;
+                min_index=i;
+            }
+        }
+      }  
+    }
+    return &(p->memory_pg_arr[min_index]);
+}
+
+
+int count_ones(uint x)
+{
+  int res=0;
+  int i;
+  for(i=0;i<32;i++)
+  {
+    if(((1<<i)&x)!=0)
+    {
+      res++;
+    }
+  }
+  return res;
+}
+
+struct free_page * lapa_alg(struct proc* p)
+{
+    int i=0;
+    int min_index=-1;
+    int min_age=-1;
+    int min_ones=0;
+    for(i=0;i<MAX_PSYC_PAGES;i++)
+    {
+     if(p->memory_pg_arr[i].va!=(char*)-1 )
+      {
+      int tmp_ones=count_ones(p->memory_pg_arr[i].age);
+          if(min_index==-1)
+        {
+            min_index=i;
+            min_age=p->memory_pg_arr[i].age;
+            min_ones=tmp_ones;
+        }
+        else//got item already
+        {
+          if(tmp_ones==min_ones)
+            {
+              if(p->memory_pg_arr[i].age<min_age)
+              {
+                  min_age=p->memory_pg_arr[i].age;
+                  min_index=i;
+                  min_ones=tmp_ones;
+              }
+            }
+            else if(tmp_ones<min_ones)
+            {
+              min_age=p->memory_pg_arr[i].age;
+              min_index=i;
+              min_ones=tmp_ones;
+            }
+        }
+      }
+    }
+    return &(p->memory_pg_arr[min_index]);
+}
+
+struct free_page * aq_alg(struct proc* p)
+{
+  struct free_page* tmp=p->tail;
+  struct free_page* oldtail=p->tail;
+  if(tmp==0)
+  {
+    panic("tail empty at aq alg\n");
+  }
+
+while(get_user_bit(tmp->va)==0)
+{
+  p->tail=p->tail->prev;
+  p->tail->next=0;
+  tmp->prev=0;
+  tmp->next=p->head;
+  p->head->prev=tmp;
+  p->head=tmp;
+  tmp=p->tail;
+  if(tmp==oldtail)
+  {
+    panic("all pages in memory are with user bit off\n");
+  }
+}
+
+
+        if(tmp->prev!=0)
+      {
+        tmp->prev->next=tmp->next;
+      }
+      if(tmp->next!=0)
+      {
+        tmp->next->prev=tmp->prev;
+      }
+      if(p->head==tmp)
+      {
+        p->head=tmp->next;
+      }
+      if(p->tail==tmp)
+      {
+        p->tail=tmp->prev;
+      }
+      return tmp;
+  
+}
+
+struct free_page * select_page_to_remove(struct proc* p)
+{
+#ifdef SCFIFO
+    return scfifo_alg(p);
+#else
+#ifdef NFUA
+    return nfu_alg(p);
+#else
+#ifdef LAPA
+    return lapa_alg(p);
+#else
+#ifdef AQ
+    return aq_alg(p);
+#endif
+#endif
+#endif
+#endif
+    panic("unknown paging method2\n");
+    return 0;
+}
+
+
+int update_memorynfua(struct proc* p,char* va)
+{
+  int i;
+  for(i=0;i<MAX_PSYC_PAGES;i++)
+  {
+    if(p->memory_pg_arr[i].va==(char*)-1)
+    {
+      p->memory_pg_arr[i].va=va;
+      p->memory_pg_arr[i].age=default_age;
+      p->memory_pg_arr[i].next=0;
+      p->memory_pg_arr[i].prev=0;
+      p->pages_in_memory_counter++;
+      return i;
+    }
+  }
+
+  panic("no empty place in memory nfua\n");
+  return -1;
+
+}
+int update_memorylapa(struct proc* p ,char* va)
+{
+    int i;
+  for(i=0;i<MAX_PSYC_PAGES;i++)
+  {
+    if(p->memory_pg_arr[i].va==(char*)-1)
+    {
+      p->memory_pg_arr[i].va=va;
+      p->memory_pg_arr[i].age=default_age;
+      p->memory_pg_arr[i].next=0;
+      p->memory_pg_arr[i].prev=0;
+      p->pages_in_memory_counter++;
+      return i;
+    }
+  }
+  panic("no empty place in memory lapa\n");
+  return -1;
+}
+
+//update the ram datastucte insert va to it return index of the inserted ram
+int update_memory(struct proc* p ,char* va)
+{
+ #ifdef SCFIFO
+ return update_memoryscfifo(p,va);
+ #else
+ #ifdef NFUA
+ return update_memorynfua(p,va);//same as update memorylap
+ #else 
+ #ifdef LAPA
+ return update_memorylapa(p,va);//same as update memory nfua
+ #else
+ #ifdef AQ
+ return update_memoryaq(p,va);
+ #endif
+ #endif
+ #endif
+ #endif
+
+panic("unknown paging method\n");
+return 0;
+}
+
 // Allocate page tables and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
 int
-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+oldallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
+
+
   char *mem;
   uint a;
 
@@ -248,6 +705,224 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
   return newsz;
 }
 
+
+int get_user_bit(char* va)
+{
+  uint user;
+  pte_t *pte = walkpgdir(myproc()->pgdir, (void*)va, 0);
+  if (!*pte)
+    panic("updateAccessBit: pte is empty");
+  user = (*pte) & PTE_U;
+  if(user==0)
+  {
+    return 0;
+  }
+  return 1;
+}
+int updateAccessBit(char *va)
+{
+  uint accessed;
+  pte_t *pte = walkpgdir(myproc()->pgdir, (void*)va, 0);
+  if (!*pte)
+    panic("updateAccessBit: pte is empty");
+  accessed = (*pte) & PTE_A;
+  (*pte) &= ~PTE_A;
+  if(accessed==0)
+  {
+    return 0;
+  }
+  else
+  {
+    return 1;
+  }
+}
+
+int pageIsInFile(int userPageVAddr, pde_t * pgdir) {
+  pte_t *pte;
+  pte = walkpgdir(pgdir, (char *)userPageVAddr, 0);
+  if((*pte&PTE_PG)&& (!(*pte&PTE_P)))
+  return 1; //PAGE IS IN FILE
+  else 
+    return 0;
+}
+
+
+struct free_page * scfifo_alg(struct proc* p)
+{
+  //cprintf("at scfifo alg\n");
+  struct free_page* oldhead=p->head;
+  struct free_page* tmp=p->head;
+
+  int accessbit_head=-1;
+  //cprintf("pages_in_memory_counter is %d\n",p->pages_in_memory_counter);
+  do
+  {
+    accessbit_head=updateAccessBit(p->head->va);
+    if(accessbit_head==-1)
+      {
+        panic("access bit is not 1 or zero in scfifo swap pages\n");
+      }
+   //   cprintf("access bit is %d \n",accessbit_head);
+      if(accessbit_head==1)
+      {
+        p->head=p->head->next;
+        p->head->prev=0;
+        tmp->next=0;
+        tmp->prev=p->tail;
+        p->tail->next=tmp;
+        p->tail=tmp;
+        tmp=p->head;
+      }
+      else//found who to switch
+      {
+        tmp=p->head;
+        if(p->head==p->tail)//if only 1 page in memory
+        {
+          p->tail->next=0;
+          p->head->prev=0;
+        }
+//        p->head=p->head->next;
+        //cprintf("no%d",t);
+      }
+    }while(p->head!=oldhead&&accessbit_head==1);
+    //cprintf("found who to switch scfifo \n");
+    //cprintf("out of loop\n");
+      if(tmp->prev!=0)
+      {
+        tmp->prev->next=tmp->next;
+      }
+      if(tmp->next!=0)
+      {
+        tmp->next->prev=tmp->prev;
+      }
+      if(p->head==tmp)
+      {
+        p->head=tmp->next;
+      }
+      if(p->tail==tmp)
+      {
+        p->tail=tmp->prev;
+      }
+      return tmp;
+}
+
+void insert_to_disk(struct proc* p,int i,struct free_page* tmp)
+{
+  p->disk_pg_arr[i].va=tmp->va;  
+  p->pages_in_swapfile_counter++;  
+  p->pagedout++;
+  if(writeToSwapFile(p,(char*)(PTE_ADDR(tmp->va)),i*PGSIZE,PGSIZE)<=0)
+  {
+    panic("failled to write to swapfile\n");
+  }
+
+  pte_t *pte1=walkpgdir(p->pgdir,(void*)tmp->va,0);
+  if(!*pte1)
+  {
+    panic("pte1 is empty\n");
+  }
+ // pte_t *pte2=walkpgdir(p->pgdir,(void*)p->disk_pg_arr[i].va,1);//map
+  tmp->va=(char*)-1;
+  p->pages_in_memory_counter--;
+// cprintf("kfree insert to disk\n");
+  kfree((char*)PTE_ADDR(P2V_WO(*pte1)));
+//  cprintf("kfree insert to disk done\n");
+  *pte1=PTE_W|PTE_U|PTE_PG;
+//  cprintf("DID THIS\n");
+  lcr3(V2P(p->pgdir));
+  //got slot in ram now for new page
+}
+
+void moveram_to_disk(struct proc* p)
+{
+  int i;
+  for(i=0;i<MAX_PSYC_PAGES;i++)
+  {
+    if(p->disk_pg_arr[i].va==(char*)-1)
+    {
+      break;
+   }
+  }
+
+  if(i>=MAX_PSYC_PAGES)
+  panic("disk full\n");
+#ifdef SCFIFO
+
+if(p->head==0||p->tail==0)
+{
+  panic("head or tail null\n");
+}
+#endif
+
+//cprintf("moveram_to_disk before scfifo\n");
+struct free_page * tmp=select_page_to_remove(p);
+//cprintf("moveram_to_disk after scfifo\n");
+insert_to_disk(p,i,tmp);
+//cprintf("after inserting page to swapfile \n");
+}
+
+// Allocate page tables and physical memory to grow process from oldsz to
+// newsz, which need not be page aligned.  Returns new size or 0 on error.
+int
+allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+{
+
+  #ifdef NONE
+  return oldallocuvm(pgdir,oldsz,newsz);
+  #endif
+
+if((myproc()!=0)&&((myproc()->pid==1)||(myproc()->parent->pid==1)))
+  return oldallocuvm(pgdir,oldsz,newsz); //sh and init dont not do any paging work like NONE only sh is child of init with pid=1
+  char *mem;
+  uint a;
+  struct proc* p =myproc();
+  if(newsz >= KERNBASE)
+    return 0;
+  if(newsz < oldsz)
+    return oldsz;
+     if (PGROUNDUP(newsz)/PGSIZE > MAX_TOTAL_PAGES) {
+        cprintf("proc is too big\n", PGROUNDUP(newsz)/PGSIZE);
+        return 0;
+      }
+  a = PGROUNDUP(oldsz);
+  for(; a < newsz; a += PGSIZE){
+    mem = kalloc();
+    if(mem == 0){
+      cprintf("allocuvm out of memory\n");
+      deallocuvm(pgdir, newsz, oldsz);
+      return 0;
+    }
+    memset(mem, 0, PGSIZE);
+
+    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+    cprintf("allocuvm out of memory (2)\n");
+    deallocuvm(pgdir, newsz, oldsz);
+  //  cprintf("kfree mem allocuvm\n");
+    kfree(mem);
+  //  cprintf("kfree mem allocuvm done\n");
+    return 0;}
+
+    if(p->pages_in_memory_counter>=MAX_PSYC_PAGES)//need to swap
+    {
+      if(p->pages_in_swapfile_counter>=MAX_PSYC_PAGES)//cant swap
+      {
+        cprintf("pages in swap file counter is %d  pages in memory counter is %d \n", p->pages_in_swapfile_counter, p->pages_in_memory_counter);
+        panic("swap file and ram full should have detected before starting to allocate memmory\n");
+      }
+
+      moveram_to_disk(p);
+      update_memory(p,(char*)a);
+      //insert_disk(p,(char*)a);
+    }
+    else//there is place in ram just insert
+    {
+      //cprintf("counter of pages in memory is %d\n",p->pages_in_memory_counter);
+      update_memory(p,(char*)a);
+    }
+  }
+  return newsz;
+}
+
 // Deallocate user pages to bring the process size from oldsz to
 // newsz.  oldsz and newsz need not be page-aligned, nor does newsz
 // need to be less than oldsz.  oldsz can be larger than the actual
@@ -255,25 +930,94 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 int
 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
+//  cprintf("deallocuvm\n");
+  //cprintf("deallocuvm\n");
   pte_t *pte;
   uint a, pa;
-
+  #ifndef NONE
+  struct proc* p =myproc();
+  #endif
   if(newsz >= oldsz)
     return oldsz;
-
   a = PGROUNDUP(newsz);
   for(; a  < oldsz; a += PGSIZE){
+    #ifndef NONE
+    int found=0;
+    #endif
     pte = walkpgdir(pgdir, (char*)a, 0);
     if(!pte)
       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
     else if((*pte & PTE_P) != 0){
       pa = PTE_ADDR(*pte);
       if(pa == 0)
-        panic("kfree");
+      {
+        panic("kfree_deallocuvm");
+      }
       char *v = P2V(pa);
+      #ifndef NONE
+      
+      int i=0;
+
+      for(i=0;i<MAX_PSYC_PAGES;i++)
+      {
+        if(p->memory_pg_arr[i].va==(char*)a)
+        {
+          if(p->memory_pg_arr[i].next!=0)
+          {
+            p->memory_pg_arr[i].next->prev=p->memory_pg_arr[i].prev;//next->prev=prev
+          }
+          if(p->memory_pg_arr[i].prev!=0)
+          {
+            p->memory_pg_arr[i].prev->next=p->memory_pg_arr[i].next;//prev->next=next
+          }
+          if(&p->memory_pg_arr[i]==p->head)
+          {
+            p->head=p->head->next;
+          }
+          if(&p->memory_pg_arr[i]==p->tail)
+          {
+            p->tail=p->tail->prev;
+          }
+          p->memory_pg_arr[i].next=0;
+          p->memory_pg_arr[i].prev=0;
+          p->memory_pg_arr[i].age=default_age;
+          p->memory_pg_arr[i].va=(char*)-1;
+          found++;
+          if(p->pgdir==pgdir)
+        p->pages_in_memory_counter--;
+            
+        }
+      }
+
+      #endif
+     // cprintf("kfree v deallocuvm\n");
       kfree(v);
+    //  cprintf("kfree v dealocuvm done\n");
       *pte = 0;
     }
+    #ifndef NONE
+    else if((*pte & PTE_PG) != 0)
+    {
+      *pte=0;
+      int i;
+      for(i=0;i<MAX_PSYC_PAGES;i++)
+      {
+        if(p->disk_pg_arr[i].va==(char*)a)
+        {
+          p->disk_pg_arr[i].va=(char*)-1;
+          p->disk_pg_arr[i].location=-1;
+          found++;
+          if(p->pgdir==pgdir)
+         p->pages_in_swapfile_counter--;
+        }
+      }
+    }
+        if(found>1)
+      {
+        cprintf("found= %d \n",found);
+        panic("found same virtual address more then once in the data strucure\n");
+      }
+   #endif
   }
   return newsz;
 }
@@ -284,7 +1028,6 @@ void
 freevm(pde_t *pgdir)
 {
   uint i;
-
   if(pgdir == 0)
     panic("freevm: no pgdir");
   deallocuvm(pgdir, KERNBASE, 0);
@@ -325,8 +1068,15 @@ copyuvm(pde_t *pgdir, uint sz)
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
       panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
+    if(!(*pte & PTE_P)&&(!(*pte & PTE_PG)))
       panic("copyuvm: page not present");
+    {
+      if(*pte& PTE_PG)
+      {
+      fixPagedOutPTE(d,i,0);
+      continue;
+      }
+    }
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
diff --git a/wc.c b/wc.c
old mode 100644
new mode 100755
diff --git a/x86.h b/x86.h
old mode 100644
new mode 100755
diff --git a/zombie.c b/zombie.c
old mode 100644
new mode 100755
